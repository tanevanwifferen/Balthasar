import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import { homedir } from "node:os";
import consola from "consola";
import {
  parse as parseCommentJson,
  stringify as stringifyCommentJson,
} from "comment-json";
import type { AppConfig, AgentConfig, AgentServerPolicy } from "../types.js";
import { loadAgents as loadAgentsMerged } from "./agents.js";

/**
 * Determine a writable agents directory.
 * Priority:
 * 1) app.agentsDir if provided (create if missing)
 * 2) ./agents (create if missing)
 * 3) ~/.llm/agents (create if missing)
 */
export function resolveWritableAgentsDir(
  app: Pick<AppConfig, "agentsDir">
): string {
  const projectDir = join(process.cwd(), "agents");
  const homeDir = join(homedir(), ".llm", "agents");

  const candidates = [app.agentsDir, projectDir, homeDir].filter(
    Boolean
  ) as string[];
  for (const dir of candidates) {
    try {
      if (!existsSync(dir)) {
        mkdirSync(dir, { recursive: true });
      }
      return dir;
    } catch (e: any) {
      // continue to next candidate
      consola.debug(
        `resolveWritableAgentsDir: cannot ensure ${dir}: ${e?.message || e}`
      );
    }
  }
  // Final fallback attempt
  try {
    mkdirSync(projectDir, { recursive: true });
    return projectDir;
  } catch (e: any) {
    // If we truly cannot create any directory, throw
    throw new Error(
      `Unable to create an agents directory (tried: ${[
        app.agentsDir,
        projectDir,
        homeDir,
      ]
        .filter(Boolean)
        .join(", ")}). Check permissions.`
    );
  }
}

/**
 * List MCP servers from config without attempting to connect.
 */
export function listMcpServers(app: AppConfig) {
  const entries = Object.entries(app.mcpServers || {});
  if (!entries.length) {
    consola.info(
      "No MCP servers configured. Add 'mcpServers' to mcp-server-config.json."
    );
    return;
  }
  console.log("\n\x1b[1mConfigured MCP Servers\x1b[0m\n");
  for (const [name, conf] of entries) {
    const enabled = conf.enabled !== false;
    const transport = conf?.sse?.url
      ? `sse (${conf.sse.url})`
      : conf?.command
        ? `stdio (command: ${conf.command})`
        : "invalid (missing sse.url or command)";
    const status = enabled ? "enabled" : "disabled";
    console.log(`- ${name} [${status}] -> ${transport}`);
  }
  console.log("");
}

/**
 * Create a new agent JSONC file with optional description and initial servers policy.
 * If any referenced server names are not configured in app.mcpServers, fail with an instructive message.
 */
export function createAgentFile(
  app: AppConfig,
  name: string,
  opts?: {
    description?: string;
    systemPrompt?: string;
    servers?: Record<string, { include?: string[]; exclude?: string[] }>;
    force?: boolean;
  }
) {
  if (!name || !/^[a-z0-9_\-]+$/i.test(name)) {
    throw new Error(
      "Invalid agent name. Use alphanumerics, underscore, or hyphen (e.g., 'researcher_v2')."
    );
  }

  // Validate referenced servers exist
  const configuredServers = new Set(Object.keys(app.mcpServers || {}));
  const requestedServers = Object.keys(opts?.servers || {});
  const missing = requestedServers.filter((s) => !configuredServers.has(s));
  if (missing.length) {
    consola.error(
      `Cannot create agent: the following servers are not configured: ${missing.join(
        ", "
      )}\nAdd them to mcp-server-config.json and install/enable the corresponding MCP servers.`
    );
    process.exitCode = 1;
    return;
  }

  const outDir = resolveWritableAgentsDir(app);
  const outPath = join(outDir, `${name}.jsonc`);
  if (existsSync(outPath) && !opts?.force) {
    consola.error(
      `Agent file already exists: ${outPath}. Use --force to overwrite or choose a different name.`
    );
    process.exitCode = 1;
    return;
  }

  const serversPolicy: Record<string, AgentServerPolicy> = {};
  for (const [srv, pol] of Object.entries(opts?.servers || {})) {
    serversPolicy[srv] = {
      include_tools: pol.include || undefined,
      exclude_tools: pol.exclude || undefined,
    };
  }

  const agentConf: AgentConfig = {
    description: opts?.description,
    systemPrompt: opts?.systemPrompt,
    servers: Object.keys(serversPolicy).length ? serversPolicy : undefined,
    // allowedAgents intentionally omitted by default
  };

  const header =
    "// Agent generated by agent generator. Edit fields as needed.\n" +
    "// You can add allowedAgents and per-server include/exclude tool lists.\n";
  const jsonc = stringifyCommentJson(agentConf, null, 2);
  writeFileSync(outPath, `${header}${jsonc}\n`, "utf-8");

  consola.success(`Created agent at ${outPath}`);
}

/**
 * Update an existing agent file. Supports setting description/systemPrompt and
 * adding/updating per-server include/exclude lists. Will fail if servers not configured.
 */
export function updateAgentFile(
  app: AppConfig,
  name: string,
  changes: {
    description?: string | null;
    systemPrompt?: string | null;
    servers?: Record<
      string,
      { include?: string[] | null; exclude?: string[] | null }
    >;
  }
) {
  if (!name) throw new Error("Agent name is required for update.");
  const dir = resolveWritableAgentsDir(app);
  const path = join(dir, `${name}.jsonc`);
  if (!existsSync(path)) {
    consola.error(
      `Agent file not found at ${path}. Cannot update. Use create to make a new agent.`
    );
    process.exitCode = 1;
    return;
  }

  // Validate servers exist
  const configuredServers = new Set(Object.keys(app.mcpServers || {}));
  const requestedServers = Object.keys(changes?.servers || {});
  const missing = requestedServers.filter((s) => !configuredServers.has(s));
  if (missing.length) {
    consola.error(
      `Cannot update agent: the following servers are not configured: ${missing.join(
        ", "
      )}\nInstall/configure these MCP servers first.`
    );
    process.exitCode = 1;
    return;
  }

  const raw = readFileSync(path, "utf-8");
  const conf = (parseCommentJson(raw, undefined, true) || {}) as AgentConfig;

  if (changes.description !== undefined) {
    conf.description =
      changes.description === null ? undefined : changes.description;
  }
  if (changes.systemPrompt !== undefined) {
    conf.systemPrompt =
      changes.systemPrompt === null ? undefined : changes.systemPrompt;
  }

  if (changes.servers) {
    conf.servers = conf.servers || {};
    for (const [srv, pol] of Object.entries(changes.servers)) {
      conf.servers[srv] = conf.servers[srv] || {};
      if (pol.include !== undefined) {
        conf.servers[srv]!.include_tools =
          pol.include === null ? undefined : pol.include;
      }
      if (pol.exclude !== undefined) {
        conf.servers[srv]!.exclude_tools =
          pol.exclude === null ? undefined : pol.exclude;
      }
    }
  }

  const jsonc = stringifyCommentJson(conf, null, 2);
  writeFileSync(path, `${jsonc}\n`, "utf-8");
  consola.success(`Updated agent at ${path}`);
}

/**
 * Inspect merged agents view (inline + directories) with source resolution.
 */
export function listAgentsMerged(app: Pick<AppConfig, "agents" | "agentsDir">) {
  const { names } = loadAgentsMerged(app);
  if (!names.length) {
    consola.info(
      "No agents found. Add JSON/JSONC files to ./agents or ~/.llm/agents, or define inline under 'agents' in config."
    );
    return;
  }
  console.log("\n\x1b[1mAvailable Agents\x1b[0m\n");
  for (const n of names) console.log("- " + n);
  console.log("");
}

// appended: AI-powered agent generation from a use case
import { connectServer } from "./mcp.js";
import { makeOpenAI } from "./llm-core.js";
import { normalizeMcpContentToString } from "./util.js";

/**
 * Discover tools per enabled server by connecting and listing tools.
 * No tool invocation is performed. Returns map: server -> Set(toolName)
 */
export async function discoverServerTools(
  app: AppConfig
): Promise<Map<string, Set<string>>> {
  const out = new Map<string, Set<string>>();
  const servers = Object.entries(app.mcpServers || {}).filter(
    ([, s]) => s.enabled !== false
  );
  const connected: Array<{
    name: string;
    close: () => Promise<void>;
    client: any;
  }> = [];
  try {
    for (const [name, conf] of servers) {
      // sanity: require sse.url or command
      const hasSse = !!(conf as any)?.sse?.url;
      const hasCmd = !!(conf?.command && typeof conf.command === "string");
      if (!hasSse && !hasCmd) continue;
      try {
        const s = await connectServer(name, conf);
        connected.push(s as any);
        const lst = await (s as any).client.listTools();
        const tools = (lst?.tools ?? [])
          .map((t: any) => t?.name)
          .filter(Boolean);
        out.set(name, new Set<string>(tools));
      } catch (e: any) {
        consola.warn(
          `discoverServerTools: cannot connect/list tools for "${name}": ${e?.message || e}`
        );
        out.set(name, new Set()); // still add server with empty set so validation can report missing tools
      }
    }
  } finally {
    await Promise.allSettled(connected.map((c) => c.close()));
  }
  return out;
}

/**
 * Summarize existing agents as examples for the LLM.
 */
function buildAgentExamplesText(
  app: Pick<AppConfig, "agents" | "agentsDir">
): string {
  const { agents } = loadAgentsMerged(app);
  const names = Object.keys(agents);
  if (!names.length) return "No existing agents available as examples.";
  const lines: string[] = [];
  for (const n of names.slice(0, 12)) {
    const a = agents[n];
    const servers = Object.keys(a.servers || {}).join(", ") || "(none)";
    const desc = (a.description || "").slice(0, 120);
    lines.push(
      `- ${n}: servers=[${servers}] ${desc ? "desc=" + JSON.stringify(desc) : ""}`
    );
  }
  if (names.length > 12) lines.push(`...and ${names.length - 12} more`);
  return ["Existing agents (for examples):", ...lines].join("\n");
}

/**
 * LLM output schema for generation.
 */
type GeneratedAgentSpec = {
  name: string; // filename stem and agent name
  description?: string;
  systemPrompt?: string;
  servers?: Record<
    string,
    { include_tools?: string[]; exclude_tools?: string[] }
  >;
  allowedAgents?: string[];
};
type GenerationResponse = {
  agents: GeneratedAgentSpec[];
};

/**
 * Generate multiple agents from a single use case.
 * - Uses LLM to decompose the use case into a set of cooperating agents
 * - Validates servers/tools exist in the current environment
 * - Writes agent JSONC files (one per agent)
 * Behavior on missing servers/tools: prints a clear error and returns non-zero exit.
 */
export async function generateAgentsFromUseCase(
  app: AppConfig,
  useCase: string,
  opts?: { force?: boolean; dryRun?: boolean }
) {
  if (!useCase || !useCase.trim()) {
    consola.error("generateAgentsFromUseCase: empty use case");
    process.exitCode = 1;
    return;
  }

  // 1) Inventory: servers and their tools (read-only)
  consola.start("Discovering MCP server tools (read-only)...");
  const toolInventory = await discoverServerTools(app);
  consola.success(
    "Discovered servers: " + [...toolInventory.keys()].join(", ")
  );

  // 2) Build prompt with examples and tool inventory
  const examplesText = buildAgentExamplesText(app);
  const serversList = [...toolInventory.entries()]
    .map(
      ([srv, tools]) =>
        `- ${srv}: ${[...tools].sort().join(", ") || "(no tools or failed to list)"}`
    )
    .join("\n");

  const sys = [
    "You are an expert AI architect of multi-agent systems.",
    "Given a use case, produce a cooperative set of agents that each has:",
    "- A clear description and systemPrompt",
    "- A mapping of servers to include/exclude tool lists (include_tools, exclude_tools)",
    "- A minimal surface (include only the tools they actually need)",
    "- allowedAgents specifying which peers they may call, if any",
    "Output STRICT JSON only matching the provided schema. Do not include comments or extra fields.",
  ].join("\n");

  const user = [
    "Use case:",
    useCase.trim(),
    "",
    examplesText,
    "",
    "Available servers and tools (you must only reference these):",
    serversList || "(none)",
    "",
    "JSON schema for output:",
    `{
  "agents": [
    {
      "name": "string (alphanumeric/_/-)",
      "description": "string?",
      "systemPrompt": "string?",
      "servers": {
        "serverName": {
          "include_tools": ["toolA", "toolB"],
          "exclude_tools": ["toolX"]
        }
      },
      "allowedAgents": ["otherAgentName"]
    }
  ]
}`,
    "Important rules:",
    "- Only use servers listed in the inventory above.",
    "- Only include tool names that are present for each server.",
    "- Prefer small, focused agents and let them delegate via allowedAgents.",
  ].join("\n");

  // 3) Call LLM
  let jsonText = "";
  try {
    const { client, model } = makeOpenAI(app, undefined);
    // Some models only support default temperature; omit it entirely to avoid 400 errors.
    const payload: any = {
      model,
      messages: [
        { role: "system", content: sys },
        { role: "user", content: user },
      ],
      response_format: { type: "json_object" } as any,
      reasoning_effort: "low",
    };
    const resp = await client.chat.completions.create(payload);
    const choice = resp.choices?.[0];
    const content = choice?.message?.content ?? "";
    jsonText =
      typeof content === "string"
        ? content
        : normalizeMcpContentToString(content);
  } catch (e: any) {
    consola.error("LLM call failed: " + (e?.message || String(e)));
    process.exitCode = 1;
    return;
  }

  // 4) Parse and validate
  let plan: GenerationResponse | undefined;
  try {
    plan = JSON.parse(jsonText);
  } catch {
    consola.error("Model did not return valid JSON. Raw output:\n" + jsonText);
    process.exitCode = 1;
    return;
  }

  const agents = (plan?.agents ?? []).filter(
    (a: any) => a && typeof a.name === "string"
  );
  if (!agents.length) {
    consola.error("No agents generated from use case.");
    process.exitCode = 1;
    return;
  }

  // Name validation
  for (const a of agents) {
    if (!/^[a-z0-9_\-]+$/i.test(a.name)) {
      consola.error(
        `Invalid agent name '${a.name}'. Use alphanumerics, underscore, or hyphen.`
      );
      process.exitCode = 1;
      return;
    }
  }

  // Server/tool validation
  const configuredServers = new Set(Object.keys(app.mcpServers || {}));
  const missingProblems: string[] = [];

  for (const a of agents) {
    const servers = a.servers || {};
    for (const [srv, pol] of Object.entries(servers)) {
      if (!configuredServers.has(srv)) {
        missingProblems.push(`[${a.name}] server '${srv}' is not configured`);
        continue;
      }
      const available = toolInventory.get(srv) || new Set<string>();
      const inc = (pol?.include_tools ?? []).filter(Boolean);
      const exc = (pol?.exclude_tools ?? []).filter(Boolean);
      for (const t of inc) {
        if (!available.has(t)) {
          missingProblems.push(
            `[${a.name}] ${srv}.include_tools references missing tool '${t}'`
          );
        }
      }
      for (const t of exc) {
        if (!available.has(t)) {
          // Excluding a non-existent tool is probably harmless, but still report to be explicit
          missingProblems.push(
            `[${a.name}] ${srv}.exclude_tools references unknown tool '${t}'`
          );
        }
      }
    }
  }

  if (missingProblems.length) {
    consola.error(
      "Cannot generate agent files because some referenced servers/tools are not available:\n" +
        missingProblems.map((x) => "- " + x).join("\n") +
        "\n\nInstall/enable the missing MCP servers or tools (and ensure they can list tools), then retry."
    );
    process.exitCode = 1;
    return;
  }

  // 4.5) Ensure a root orchestrator agent exists that can run the full task and delegate.
  // It will embed the original use case as its systemPrompt and allow calling all generated agents.
  (function ensureRootAgent() {
    const existingNames = new Set(agents.map((a) => a.name));
    const slugify = (s: string) =>
      (s || "")
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, " ")
        .trim()
        .split(/\s+/)
        .slice(0, 5)
        .join("_");
    const base = slugify(useCase) || "use_case";
    let rootName = `${base}_root`;
    // Avoid collisions
    let i = 2;
    while (existingNames.has(rootName)) {
      rootName = `${base}_root_${i++}`;
    }
    // Compose root orchestrator agent
    const rootAgent: GeneratedAgentSpec = {
      name: rootName,
      description:
        "Root orchestrator that holds the full task instructions and delegates to specialized agents.",
      systemPrompt: [
        "You are the root orchestrator for this task.",
        "Full task/use case to accomplish (do not lose details):",
        useCase.trim(),
        "",
        "Behavioral rules:",
        "- Plan and break down the task into steps.",
        "- Delegate to specialized agents using the call_agent tool according to allowedAgents.",
        "- Keep tools surface minimal; the orchestrator does not use MCP tools directly.",
        "- Synthesize final results and ensure the overall objective is met.",
      ].join("\n"),
      servers: undefined, // Orchestrator does not need direct tools; delegates via call_agent
      allowedAgents: agents.map((a) => a.name),
    };
    agents.unshift(rootAgent);
  })();

  // 5) Write files (or dry-run)
  const outDir = resolveWritableAgentsDir(app);
  if (opts?.dryRun) {
    console.log("\n\x1b[1mPlanned Agents (dry-run)\x1b[0m\n");
    for (const a of agents) {
      console.log("- " + a.name);
    }
    console.log(`\nFiles would be written to: ${outDir}\n`);
    return;
  }

  for (const a of agents) {
    // Transform to our AgentConfig-compatible structure
    const serversPolicy: Record<string, AgentServerPolicy> = {};
    for (const [srv, pol] of Object.entries(a.servers || {})) {
      serversPolicy[srv] = {
        include_tools: pol?.include_tools,
        exclude_tools: pol?.exclude_tools,
      };
    }
    const conf: AgentConfig = {
      description: a.description,
      systemPrompt: a.systemPrompt,
      servers: Object.keys(serversPolicy).length ? serversPolicy : undefined,
      allowedAgents: Array.isArray(a.allowedAgents)
        ? a.allowedAgents
        : undefined,
    };
    const header =
      "// Agent generated from use case by the AI agent generator.\n" +
      "// Edit as needed. allowedAgents controls cross-agent delegation.\n";
    const jsonc = stringifyCommentJson(conf, null, 2);
    const outPath = join(outDir, `${a.name}.jsonc`);
    if (existsSync(outPath) && !opts?.force) {
      consola.error(
        `Refusing to overwrite existing file: ${outPath}. Use --force to overwrite.`
      );
      process.exitCode = 1;
      return;
    }
    writeFileSync(outPath, `${header}${jsonc}\n`, "utf-8");
    consola.success(`Wrote ${outPath}`);
  }

  console.log("");
  consola.success("Agent generation completed.");
}
